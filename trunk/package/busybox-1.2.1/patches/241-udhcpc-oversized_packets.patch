diff -ruN busybox-1.2.1-old/networking/udhcp/packet.c busybox-1.2.1-new/networking/udhcp/packet.c
--- busybox-1.2.1-old/networking/udhcp/packet.c	2006-07-01 00:42:02.000000000 +0200
+++ busybox-1.2.1-new/networking/udhcp/packet.c	2006-11-19 01:04:40.000000000 +0100
@@ -111,6 +111,10 @@
 	return ~sum;
 }
 
+int udhcp_get_payload_len(struct dhcpMessage *payload)
+{
+	return sizeof(struct dhcpMessage) - MAX_OPTIONS_LEN + end_option(payload->options) + sizeof(payload->options[0]);
+}
 
 /* Construct a ip/udp header for a packet, and specify the source and dest hardware address */
 int udhcp_raw_packet(struct dhcpMessage *payload, uint32_t source_ip, int source_port,
@@ -120,6 +124,7 @@
 	int result;
 	struct sockaddr_ll dest;
 	struct udp_dhcp_packet packet;
+	int p_len = udhcp_get_payload_len(payload);
 
 	if ((fd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP))) < 0) {
 		DEBUG(LOG_ERR, "socket call failed: %m");
@@ -128,6 +133,7 @@
 
 	memset(&dest, 0, sizeof(dest));
 	memset(&packet, 0, sizeof(packet));
+	memcpy(&(packet.data), payload, p_len);
 
 	dest.sll_family = AF_PACKET;
 	dest.sll_protocol = htons(ETH_P_IP);
@@ -145,18 +151,19 @@
 	packet.ip.daddr = dest_ip;
 	packet.udp.source = htons(source_port);
 	packet.udp.dest = htons(dest_port);
-	packet.udp.len = htons(sizeof(packet.udp) + sizeof(struct dhcpMessage)); /* cheat on the psuedo-header */
+	p_len += sizeof(packet.udp);
+	packet.udp.len = htons(p_len);
 	packet.ip.tot_len = packet.udp.len;
-	memcpy(&(packet.data), payload, sizeof(struct dhcpMessage));
-	packet.udp.check = udhcp_checksum(&packet, sizeof(struct udp_dhcp_packet));
+	p_len += sizeof(packet.ip);
+	packet.udp.check = udhcp_checksum(&packet, p_len);
 
-	packet.ip.tot_len = htons(sizeof(struct udp_dhcp_packet));
+	packet.ip.tot_len = htons(p_len);
 	packet.ip.ihl = sizeof(packet.ip) >> 2;
 	packet.ip.version = IPVERSION;
 	packet.ip.ttl = IPDEFTTL;
 	packet.ip.check = udhcp_checksum(&(packet.ip), sizeof(packet.ip));
 
-	result = sendto(fd, &packet, sizeof(struct udp_dhcp_packet), 0, (struct sockaddr *) &dest, sizeof(dest));
+	result = sendto(fd, &packet, p_len, 0, (struct sockaddr *) &dest, sizeof(dest));
 	if (result <= 0) {
 		DEBUG(LOG_ERR, "write on socket failed: %m");
 	}
@@ -201,7 +208,7 @@
 		return -1;
 	}
 
-	result = write(fd, payload, sizeof(struct dhcpMessage));
+	result = write(fd, payload, udhcp_get_payload_len(payload));
 	close(fd);
 	return result;
 }
diff -ruN busybox-1.2.1-old/networking/udhcp/packet.h busybox-1.2.1-new/networking/udhcp/packet.h
--- busybox-1.2.1-old/networking/udhcp/packet.h	2006-07-01 00:42:02.000000000 +0200
+++ busybox-1.2.1-new/networking/udhcp/packet.h	2006-11-19 00:49:38.000000000 +0100
@@ -4,6 +4,8 @@
 #include <netinet/udp.h>
 #include <netinet/ip.h>
 
+#define MAX_OPTIONS_LEN  308
+
 struct dhcpMessage {
 	uint8_t op;
 	uint8_t htype;
@@ -20,7 +22,7 @@
 	uint8_t sname[64];
 	uint8_t file[128];
 	uint32_t cookie;
-	uint8_t options[308]; /* 312 - cookie */
+	uint8_t options[MAX_OPTIONS_LEN]; /* 312 - cookie */
 };
 
 struct udp_dhcp_packet {
